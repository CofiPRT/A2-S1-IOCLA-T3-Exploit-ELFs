-------------------------------------------
------------------ IOCLA ------------------
----- Tema 3. Exploit ELFs, not elves -----
-------------------------------------------

Cuprins:
	Task 1..................Linia  17
	Task 2..................Linia  41
	Task 3..................Linia  89
	Task 4..................Linia 140
	Alte precizari..........Linia 191	

==============
=== Task 1 ===
==============
	- Prin call-ul DE LA '0x08048734' (main) se ajunge LA '0x0804864c', adresa
	ce reprezinta inceputul unei functii ce pare sa aloce spatiu pentru
	0xea (234) bytes.

	- Imediat dupa, in acest spatiu alocat se incearca a se
	citi prin 'read' 0x157 (343) bytes (primul 'push' reprezinta al treilea
	parametrul al lui read, anume 'size_t nbyte' semnificand numarul de bytes
	ce vor fi cititi).

	- Aceasta manevra este periculoasa, intrucat dupa citirea a 234 bytes avem
	nevoie de doar inca 2 bytes in plus pentru a schimba, de exemplu, adresa
	de retur salvata pe stiva, care va fi folosita de instructiunea 'ret' in
	cadrul functiei.

	- Pana se vor citi 343 bytes putem modifica o foarte mare parte a stivei
	dupa placul nostru.

	- Pe de alta parte, in acest caz particular, se observa cum imediat dupa
	apelul 'read' se face apel la adresa ce se gaseste la 'ebp + 8', care si
	aceasta poate fi suprascrisa prin metoda antepusa.

==============
=== Task 2 ===
==============
	- In cadrul functiei ce incepe la adresa A se citesc B bytes:
	A: B
	0x080485fe: 0x150 (336)
	0x08048618: 0x087 (135)
	0x08048632: 0x090 (144)
	0x0804864c: 0x157 (343)
	(Acestea sunt primele 4 functii apelate in main)

	- In cadrul functiei 0x0804864c (functia a 4-a) se apeleaza exit, deci nu
	mai conteaza apelurile funtiilor urmatoare

	- In cadrul functiilor pana la functia a 4-a inclusiv, se citesc
	|336 + 135 + 144 + 343 = 958 bytes|

	- Cu toate acestea, in cadrul celei de-a 4-a citiri, dupa citirea
	caracterelor din payload ce incep de la offset-ul
	|336 + 135 + 144 + 234 = 849|
	urmatoarele 8 caractere citite vor suprascrie pe stiva, in ordine, ebp-ul
	precedent si adresa de retur a functiei.

	- Urmatoarele 4 caractere citite vor suprascrie pe stiva valoarea folosita
	drept prim argument pentru cea de-a 4-a functie (0x0804864c).

	- Acest prim argument este folosit ca o adresa asupra careia se executa
	instructiunea 'call'. Astfel, prin scrierea in payload a unei adrese
	corespunzatoare, imediat la offset-ul 849 + 8 = 857, putem controla
	executia programului

	- De exemplu, fisierul 'nice_payload' a fost generat
	| 'A' * 857 + '\xb1\x85\x04\x08' + 'C' * 100 |
	Format din 857 de caractere 'A', inutile, nefolosite, urmate de adresa
	(pe little endian) in hexazceimal 080485b1. Se continua cu alte 100 de
	caractere inutile ('C'), suficiente pentru a servi input-ului la
	care se asteapta ultima instructiune 'read' din executia programului.

	- Adresa antepusa corespunde inceputului label-ului 'print_flag' ce
	reprezinta inceputul unei functii ce executa pasii necesari realizarii
	cerintei 2.

	- Fiind pozitionata la offset-ul potrivit, aceasta adresa va fi executata
	de functia 0x0804864c.

	- Astfel, se poate afisa
	NICE_FLAG{8577f03b1338697a6860a218365b438d}

==============
=== Task 3 ===
==============
	- Similar task-ului 2, la acest task dupa fiecare apel 'read' se testeaza
	daca un anume element citit este egal cu o valoare. De aici, urmatorul
	tabel este de forma
	FUNCTION | READ BYTES | VALUE | OFFSET START* | OFFSET PREVIOUS**
	0x080485fe | 139 | 0x59c4631a | 15  | 15
	0x0804862b | 170 | 0x625ae1e4 | 188 | 49
	0x08048658 | 215 | 0xf9e083c7 | 366 | 57
	0x08048685 | 927 | 0x1ba75f4e | 723 | 199

	Explicatii:
	* Offset-ul fata de inceputul payload-ului unde se va afla DWORD-ul ce va
	fi comparat in functie
	** Offset-ul fata de citirea precedenta

	- Similar task-ului 2, ultima functie din tabel prezinta o vulnerabilitate
	in sensul ca se aloca spatiu pentru 472 de bytes si se citesc 927 de bytes.
	Acest numar este suficient de mare pentru a suprascrie ce se afla la adresa
	folosita drept prim argument pentru functia 0x08048685 (functia a 4-a).

	- Offset-ul fata de inceputul payload-ului la care se afla valoarea cu care
	vrem sa suprascriem va fi
	| 139 + 170 + 215 + 472 + 8 = 1004 |
	Primele 3 numere: citirile din primele 3 'read'-uri
	472: Bytes alocati inainte de cel de-al 4-lea 'read'
	8: Offset peste vechiul 'ebp' si adresa de retur salvate pe stiva

	- Dorim ca primul argument al functiei sa fie adresa lui 'print_flag'
	astfel incat executia programului sa continue acolo prin apelul din
	functia 0x08048685 (functia a 4-a). Aceasta adresa este 0x080485b1.

	- Se generaza fisierul 'naughty_payload' astfel:
	'A' *  15 + '\x1a\x63\xc4\x59' + 'A' * 120 +
	'B' *  49 + '\xe4\xe1\x5a\x62' + 'B' * 117 +
	'C' *  57 + '\xc7\x83\xe0\xf9' + 'C' * 154 +
	'D' * 199 + '\x4e\x5f\xa7\x1b' + 'D' * 269 +
	'E' *   8 + '\xb1\x85\x04\x08' + 'E' * 443

	- Toate caracterele A-E sunt inutile, folosite pentru a genera offset-uri.
	Mai sus sunt grupate pe cate o linie caracterele ce vor fi citite de un
	singur 'read' (mai putin ultimele 2 linii; ambele vor fi citite de cel
	de-al 4-lea 'read').

	- Astfel, se poate afisa
	NAUGHTY_FLAG{3ca7e2b5011091d61b7e228470961cf8}

	ebp: 0xffffce78
	+50: 0xFFFFCEAA

==============
=== Task 4 ===
==============
	- In primul rand, dorim sa ne salvam propriul cod undeva in program, iar un
	loc bun pare a fi buffer-ul de la al 4-lea 'read' (e suficient de mare).

	- Astfel, pana la cel de-al 4-lea 'read', primele 3 vor citi aceleasi
	caractere ca cele din naughty_payload (de la task-ul anterior).

	- Imediat la inceputul celui de-al 4-lea buffer, vom introduce codul nostru
	(cod masina). Acesta incepe de fapt cu un numar de instructiuni 'nop' (in
	cazul nostru particular, 100) pentru a favoriza gasirea unei adrese din
	cadrul acestui buffer (explicat mai jos).

	- Prin gdb, observam ca adresa la care va fi introdus primul caracter din
	buffer este 0xffffce78. Cu toate acestea, utilitarul gdb adauga pe stiva
	informatii cu ajutorul carora isi desfasoara corespunzator rularea.
	Din acest motiv, adresa reala (la rulare normala) a buffer-ului poate fi
	mai mare. Prin incercari (putine, din moment ce avem un decent de
	instructiuni 'nop'), am gasit o adresa din interiorul lantului de 'nop'-uri,
	anume 0xffffceff.

	- Revenind, cel de-al 4-lea read va citi:
		cele 100 de instructiuni 'nop'
		codul masina cu marimea de 27 de bytes
		inca 72 de de caractere inutile pentru a ajunge la offset-ul la care
			vom introduce valoarea 0x1ba75f4e (din task-ul 3)
		de aici, citirea continua sub aceeasi forma ca la task-ul 3, cu
		exceptia ca dorim ca adresa catre care va porni executia programului
		sa fie, de data asta, 0xffffceff, anume o adresa din mijlocul lantului
		de 'nop'-uri.

	- Prin instructiunile 'nop', ii oferim programului de shell sansa sa "ocupe"
	mai mult spatiu pe stiva, astfel incat oriunde ar sari executia programului
	in lantul de 'nop'-uri, acestea se vor executa pe rand pana se va ajunge
	la programul propriu-zis.

	- Din moment ce intreg programul (naughty) isi termina executia dupa
	citirea payload-ului, avem nevoie de un input/payload "infinit" pentru
	a tine shell-ul pornit.

	- Astfel, prin comanda 'cat naughty_payload -', 'cat'
	va concatena 'naughty_payload' la stdin ('-'). Prin pipe-ul catre
	executabilul nostru 'cat naughty_payload - | ./naughty', el va astepta
	in continuu input de la stdin, si putem inchide shell-ul in orice moment
	dorim.

	- Dupa comanda 'exit' se va iesi din shell, si dupa se va astepta
	input de la stdin pentru a termina si executia programului (putem scrie
	orice).

======================
=== Alte precizari ===
======================
	Tin sa precizez, drept feedback, ca mi-a placut aceasta tema (cerinta) si
	tematica ei. Totodata, consider ca partea de debugging ar trebui facuta
	mai devreme in cadrul semestrului, pentru a servi la realizarea tuturor
	temelor.